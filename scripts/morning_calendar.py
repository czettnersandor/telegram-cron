#!/usr/bin/env python3
"""
Morning Calendar Script
Fetches iCal calendar from URL and displays today's events,
including occurrences generated by RRULE recurrence rules.
"""
import urllib.request
from datetime import datetime, date, timedelta
import sys


# â”€â”€ iCal fetching â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def fetch_ical(url):
    """Fetch iCal content from URL"""
    try:
        with urllib.request.urlopen(url) as response:
            return response.read().decode('utf-8')
    except Exception as e:
        print(f"Error fetching calendar: {e}", file=sys.stderr)
        sys.exit(1)


# â”€â”€ Low-level line parsing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def unfold_lines(ical_content):
    """
    Unfold iCal content per RFC 5545:
    a CRLF (or LF) followed by a space/tab is a line continuation.
    """
    content = ical_content.replace('\r\n', '\n').replace('\r', '\n')
    content = content.replace('\n ', '').replace('\n\t', '')
    return content.splitlines()


def parse_ical_line(line):
    """
    Parse one unfolded iCal property line.
    Returns (key, params_dict, value) or (None, {}, None).

    e.g. 'DTSTART;TZID=Europe/Budapest:20241015T090000'
      -> ('DTSTART', {'TZID': 'Europe/Budapest'}, '20241015T090000')
    """
    if ':' not in line:
        return None, {}, None

    prop, value = line.split(':', 1)
    parts = prop.split(';')
    key = parts[0].strip()
    params = {}
    for param in parts[1:]:
        if '=' in param:
            pk, pv = param.split('=', 1)
            params[pk.strip()] = pv.strip()

    return key, params, value


# â”€â”€ Datetime helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def parse_datetime(value, params=None):
    """
    Parse an iCal datetime/date string into a datetime.
    Handles:
      YYYYMMDDTHHMMSS   - floating local time
      YYYYMMDDTHHMMSSZ  - UTC (Z stripped, not converted)
      YYYYMMDD          - all-day (returned as midnight datetime)
    Returns None on failure.
    """
    value = value.strip().rstrip('Z')
    if 'T' in value:
        try:
            return datetime.strptime(value, '%Y%m%dT%H%M%S')
        except ValueError:
            return None
    elif len(value) == 8:
        try:
            return datetime.strptime(value, '%Y%m%d')
        except ValueError:
            return None
    return None


def is_all_day(value):
    """Return True if the raw DTSTART value represents an all-day event."""
    return 'T' not in value.strip()


# â”€â”€ RRULE parser â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Maps iCal weekday abbreviations to Python weekday() integers (Mon=0)
WEEKDAY_MAP = {'MO': 0, 'TU': 1, 'WE': 2, 'TH': 3, 'FR': 4, 'SA': 5, 'SU': 6}


def parse_rrule(rrule_value):
    """
    Parse an RRULE value string into a dict.
    e.g. 'FREQ=WEEKLY;INTERVAL=2;BYDAY=MO,WE'
      -> {'FREQ': 'WEEKLY', 'INTERVAL': 2, 'BYDAY': ['MO', 'WE']}
    """
    rule = {}
    for part in rrule_value.strip().split(';'):
        if '=' not in part:
            continue
        k, v = part.split('=', 1)
        k, v = k.strip(), v.strip()

        if k == 'FREQ':
            rule['FREQ'] = v
        elif k == 'INTERVAL':
            rule['INTERVAL'] = int(v)
        elif k == 'COUNT':
            rule['COUNT'] = int(v)
        elif k == 'UNTIL':
            rule['UNTIL'] = parse_datetime(v)
        elif k == 'BYDAY':
            rule['BYDAY'] = [d.strip() for d in v.split(',')]
        elif k == 'BYMONTHDAY':
            rule['BYMONTHDAY'] = [int(d) for d in v.split(',')]
        elif k == 'BYMONTH':
            rule['BYMONTH'] = [int(m) for m in v.split(',')]

    return rule


def byday_matches(dt, byday_list):
    """
    Return True if dt matches any entry in byday_list.
    Supports plain weekday codes (MO, TU, ...) and nth-weekday
    prefixes like 1MO (first Monday) or -1FR (last Friday of month).
    """
    dow = dt.weekday()  # 0=Mon ... 6=Sun
    for entry in byday_list:
        day_code = entry.lstrip('+-0123456789')
        if WEEKDAY_MAP.get(day_code) != dow:
            continue

        prefix = entry[: len(entry) - len(day_code)]
        if not prefix or prefix in ('+', '-'):
            return True

        import calendar
        n = int(prefix)
        if n > 0:
            # nth occurrence from start of month
            first_dow = dt.replace(day=1).weekday()
            delta = (WEEKDAY_MAP[day_code] - first_dow) % 7
            nth_day = 1 + delta + (n - 1) * 7
            if dt.day == nth_day:
                return True
        else:
            # nth occurrence from end of month
            last_day = calendar.monthrange(dt.year, dt.month)[1]
            last_dow = dt.replace(day=last_day).weekday()
            delta = (last_dow - WEEKDAY_MAP[day_code]) % 7
            nth_from_end_day = last_day - delta + (n + 1) * 7
            if dt.day == nth_from_end_day:
                return True

    return False


# â”€â”€ Recurrence expansion â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def occurs_on(event, target_date):
    """
    Return True if the event has an occurrence on target_date.
    Handles both non-recurring events and RRULE recurrences,
    respecting EXDATE exclusions.
    """
    start = event.get('start')
    if start is None:
        return False

    # Non-recurring: simple date match
    if 'rrule' not in event:
        return start.date() == target_date

    rrule = event['rrule']
    freq = rrule.get('FREQ', '')
    interval = rrule.get('INTERVAL', 1)
    until = rrule.get('UNTIL')
    count = rrule.get('COUNT')
    byday = rrule.get('BYDAY', [])
    bymonthday = rrule.get('BYMONTHDAY', [])
    bymonth = rrule.get('BYMONTH', [])
    exdates = event.get('exdates', set())

    # Series cannot start after the target
    if start.date() > target_date:
        return False

    current = start
    occurrence_count = 0

    while True:
        current_date = current.date()

        if until and current > until:
            return False
        if count is not None and occurrence_count >= count:
            return False
        if current_date > target_date:
            return False

        # Check day-level constraints
        day_ok = True
        if byday and not byday_matches(current, byday):
            day_ok = False
        if bymonthday and current.day not in bymonthday:
            day_ok = False
        if bymonth and current.month not in bymonth:
            day_ok = False

        if day_ok:
            occurrence_count += 1
            if current_date == target_date and current_date not in exdates:
                return True

        # Advance to next candidate
        if freq == 'DAILY':
            current += timedelta(days=interval)

        elif freq == 'WEEKLY':
            if byday:
                # Step one day at a time; skip whole weeks that fall outside
                # the interval boundary.
                current += timedelta(days=1)
                days_since_start = (current.date() - start.date()).days
                week_number = days_since_start // 7
                if week_number % interval != 0 and current.weekday() == start.weekday():
                    skip = (interval - week_number % interval) * 7
                    current += timedelta(days=skip - 1)
            else:
                current += timedelta(weeks=interval)

        elif freq == 'MONTHLY':
            import calendar
            month = current.month - 1 + interval
            year = current.year + month // 12
            month = month % 12 + 1
            max_day = calendar.monthrange(year, month)[1]
            day = min(current.day, max_day)
            current = current.replace(year=year, month=month, day=day)

        elif freq == 'YEARLY':
            current = current.replace(year=current.year + interval)

        else:
            return False  # Unknown frequency


# â”€â”€ Event parsing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def parse_events(ical_content):
    """Parse iCal content and return a list of event dicts."""
    events = []
    lines = unfold_lines(ical_content)
    in_event = False
    current_event = {}

    for line in lines:
        line = line.strip()
        if not line:
            continue

        if line == 'BEGIN:VEVENT':
            in_event = True
            current_event = {}
        elif line == 'END:VEVENT':
            in_event = False
            if current_event:
                events.append(current_event)
        elif in_event:
            key, params, value = parse_ical_line(line)
            if key is None:
                continue

            if key == 'SUMMARY':
                current_event['summary'] = value
            elif key == 'DTSTART':
                dt = parse_datetime(value)
                if dt is not None:
                    current_event['start'] = dt
                    current_event['all_day'] = is_all_day(value)
            elif key == 'DTEND':
                dt = parse_datetime(value)
                if dt is not None:
                    current_event['end'] = dt
            elif key == 'DURATION':
                current_event['duration_raw'] = value
            elif key == 'RRULE':
                current_event['rrule'] = parse_rrule(value)
            elif key == 'EXDATE':
                # EXDATE may appear multiple times; values may be comma-separated
                exdates = current_event.setdefault('exdates', set())
                for raw_dt in value.split(','):
                    dt = parse_datetime(raw_dt)
                    if dt:
                        exdates.add(dt.date())

    return events


# â”€â”€ Duration helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def parse_duration(duration_str):
    """
    Parse an iCal DURATION string into a timedelta.
    Handles P[n]W and P[n]DT[n]H[n]M[n]S forms.
    """
    import re
    s = duration_str.strip().lstrip('P')

    m = re.match(r'^(\d+)W$', s)
    if m:
        return timedelta(weeks=int(m.group(1)))

    days = hours = minutes = seconds = 0
    date_part, _, time_part = s.partition('T')
    if date_part:
        m = re.search(r'(\d+)D', date_part)
        if m:
            days = int(m.group(1))
    if time_part:
        for pattern, key in [(r'(\d+)H', 'h'), (r'(\d+)M', 'm'), (r'(\d+)S', 's')]:
            m = re.search(pattern, time_part)
            if m:
                val = int(m.group(1))
                if key == 'h':
                    hours = val
                elif key == 'm':
                    minutes = val
                else:
                    seconds = val
    return timedelta(days=days, hours=hours, minutes=minutes, seconds=seconds)


# â”€â”€ Today's events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def get_todays_events(events):
    """
    Return event dicts for today. For recurring events whose original
    DTSTART is in the past, the start/end are shifted to today's date
    while preserving the original time-of-day.
    """
    today = date.today()
    todays_events = []

    for event in events:
        if not occurs_on(event, today):
            continue

        start = event['start']
        result = dict(event)

        # Shift recurring occurrences to today's date
        if start.date() != today:
            shift = timedelta(days=(today - start.date()).days)
            result['start'] = start + shift
            if event.get('end'):
                result['end'] = event['end'] + shift

        # Derive end from DURATION if DTEND is absent
        if not result.get('end') and event.get('duration_raw'):
            try:
                result['end'] = result['start'] + parse_duration(event['duration_raw'])
            except Exception:
                pass

        todays_events.append(result)

    todays_events.sort(key=lambda x: x['start'])
    return todays_events


# â”€â”€ Formatting â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def format_time(dt):
    return dt.strftime('%H:%M')


def format_event_line(event):
    summary = event.get('summary', 'Untitled Event')

    if event.get('all_day'):
        return f"{summary} â€” all day"

    start_time = format_time(event['start'])
    end = event.get('end')
    end_time = format_time(end) if end else '??:??'
    return f"{summary} â€” {start_time}â€“{end_time}"


# â”€â”€ Entry point â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def main():
    if len(sys.argv) < 2:
        print("Error: No iCal URL provided", file=sys.stderr)
        sys.exit(1)

    ical_url = sys.argv[1]

    ical_content = fetch_ical(ical_url)
    events = parse_events(ical_content)
    todays_events = get_todays_events(events)

    if not todays_events:
        print("NOUPDATE")
        return

    today = datetime.now()
    print("Good morning Sandor!")
    print()
    print(f"ðŸ“… Today's Schedule â€” {today.strftime('%A, %b %d')}:")
    print()
    for event in todays_events:
        print(format_event_line(event))


if __name__ == '__main__':
    main()
